import define1 from "./7e0e77ed848d004b@2084.js";
import define2 from "./5743bb840ff114f8@408.js";

function _1(md){return(
md`# Part 5) SL Correctness: comparing with JSTS`
)}

function _2(md){return(
md`The purpose of this demo is to test the geometric correctness of [the Sector List (SL) implementation](../part-1-sector-list-implementation-in-javascript). For this, we compare our SL results with the results of [JSTS](https://github.com/bjornharrtell/jsts), a port in JavaScript language of the well established library [Java Topology Suite (JTS)](https://github.com/locationtech/jts) for creating and manipulating vector geometry.

The following procedure is used to generate the tests:
- Two random polygons are created using the [implementation described in Part 3](../part-4-sector-lists-experiment-2-random-polygons). You can choose below three parameters to change the complexity of the randomized geometry.
- The intersection of the two polygons is computed using the JSTS library.
- The circulations are converted to a Sector List, a scalar transformation analogous to intersection is applied, and the result of the scalar transformation is converted to vertex circulations.
- Finally, the vertices generated by the Sector List and the JSTS operations are compared. The expected result is that the circulations be the same.`
)}

function _3(md){return(
md`### Generating a pair of polygons`
)}

function _4(tex,md){return(
md`Our generator creates random polygons placing their vertices around a center point at different distances and angles. Shapes are controlled by the number of vertices, an _"irregularity"_ factor and a _"spikiness"_ factor, which controls the radius variation. To increase the probability of intersection, average coverage is equals to 1. More details about these parameters [in this notebook](../part-4-sector-lists-experiment-2-random-polygons). The result is an array ${tex`[[x_1,y_1],[x_2,y_2],...,[x_n,y_n]]`}.`
)}

function _shapeParams(Inputs){return(
Inputs.form({
  irregularity: Inputs.range([0, 1], {
    label: "Irregularity",
    step: 0.01,
    value: 0.5
  }),
  spikiness: Inputs.range([0, 0.5], {
    label: "Spikiness",
    step: 0.01,
    value: 0.2
  }),
  nvtx: Inputs.range([3, 50], {
    label: "Vertices",
    step: 1,
    value: 10
  })
})
)}

function _polygons(coverSquarePolygons,shapeParams){return(
coverSquarePolygons(
  500,
  1,
  2,
  shapeParams.nvtx,
  shapeParams.irregularity,
  shapeParams.spikiness
)
)}

function _7(cell){return(
cell`polygons = coverSquarePolygons(
  500,
  1,
  2,
  shapeParams.nvtx,
  shapeParams.irregularity,
  shapeParams.spikiness
)`
)}

function _8(drawPolygons,polygons){return(
drawPolygons(polygons)
)}

function _9(cell){return(
cell`drawPolygons(polygons)`
)}

function _10(md){return(
md`### Intersection by JSTS library`
)}

function _11(md){return(
md`Both vertex circulations are converted to Well-Know Text (WKT), thus parsing to JSTS geometry objects. The intersection operation results in a new JSTS geometry object, which is converted back in an array of vertices.`
)}

function _polygonsJSTS(polygonArrayToWKT,polygons,jsts)
{
  const wkts = polygonArrayToWKT(polygons);
  const wktreader = new jsts.io.WKTReader();
  const result = [];
  for (let wkt of wkts) {
    result.push(wktreader.read(wkt));
  }
  return result;
}


function _13(cell){return(
cell`polygonsJSTS = {
  const wkts = polygonArrayToWKT(polygons);
  const wktreader = new jsts.io.WKTReader();
  const result = [];
  for (let wkt of wkts) {
    result.push(wktreader.read(wkt));
  }
  return result;
}`
)}

function _interJSTS(polygonsJSTS){return(
polygonsJSTS[0].intersection(polygonsJSTS[1])
)}

function _15(cell){return(
cell`interJSTS = polygonsJSTS[0].intersection(polygonsJSTS[1]);`
)}

function _16(drawPolygons,JSTSGeomToArray,interJSTS){return(
drawPolygons([JSTSGeomToArray(interJSTS)])
)}

function _17(cell){return(
cell`drawPolygons([JSTSGeomToArray(interJSTS)]);`
)}

function _18(md){return(
md`### Intersection with Sector Lists`
)}

function _19(tex,md){return(
md`Both arrays are converted to a single Sector List representation mapping each polygon interior to ${tex`+1`}. In this way, the points contained in the intersection area are mapped to ${tex`+2`}. Hover your mouse on the canvas below to inspect the field values.`
)}

function _polygonSL(polygons,SectorList)
{
  let sectors = [];
  for (let poly of polygons)
    sectors.push(...SectorList.convertFrom(poly.flat(), 1).sectors);

  return SectorList.fromSectorArray(sectors);
}


function _21(cell){return(
cell`polygonSL = {
  let sectors = [];
  for (let poly of polygons)
    sectors.push(...SectorList.convertFrom(poly.flat(), 1).sectors);

  return SectorList.fromSectorArray(sectors);
}`
)}

function _22(fieldRender,polygonSL,d3){return(
fieldRender(polygonSL, {
  fieldColor: d3.scaleOrdinal(d3.range(20), [
  "#fff",
  "#eee",
    "#666"
  ]),
  showEdges: true,
  tooltipMap: "auto"
})
)}

function _23(cell){return(
cell`fieldRender(polygonSL, {
  fieldColor: d3.scaleOrdinal(d3.range(20), [
  "#fff",
  "#eee",
    "#666"
  ]),
  showEdges: true,
  tooltipMap: "auto"
})`
)}

function _24(tex,md){return(
md`A scalar transformation that gives the intersection area must return ${tex`1`} when the field value at a point is ${tex`2`} and ${tex`0`} otherwise. Thus, the transformed SL is converted in an array of vertices.`
)}

function _interSL(polygonSL){return(
polygonSL.scalarTransformation(x => x == 2 ? 1 : 0)
)}

function _26(cell){return(
cell`interSL = polygonSL.scalarTransformation(x => x == 2 ? 1 : 0);`
)}

function _27(drawPolygons,SLToArray,interSL){return(
drawPolygons([SLToArray(interSL)])
)}

function _28(cell){return(
cell`drawPolygons([SLToArray(interSL)]);`
)}

function _29(md){return(
md`### Comparing results`
)}

function _30(md){return(
md`Since we have the intersection results performed by JSTS and by SL as array of vertices, the two arrays are sorted by their coordinate values. Therefore, a loop compares whether the coordinates differences between the i-th vertices of both arrays is not greater than a tolerance. This tolerance is necessary due to floating-point calculations in SL and JSTS operations.`
)}

function _compareResults(JSTSGeomToArray,SLToArray){return(
function(jstsgeom,sl) {
  const TOLERANCE = 1/10e-10;
  const arrayjsts = JSTSGeomToArray(jstsgeom).sort();
  const arraysl = SLToArray(sl).sort();
  if (arrayjsts.length != arraysl.length) {
    return false;
  }
  for (let i=0;i < arraysl.length; ++i) {
    const vsl = arraysl[i];
    const vjsts = arrayjsts[i];
    if (Math.abs(vsl[0] - vjsts[0]) > TOLERANCE || Math.abs(vsl[1] - vjsts[1]) > TOLERANCE) {
      return false;//[i,arraysl,arrayjsts];
    }
  }
  return true;
}
)}

function _32(cell){return(
cell`compareResults = function(jstsgeom,sl) {
  const TOLERANCE = 1/10e-10;
  const arrayjsts = JSTSGeomToArray(jstsgeom).sort();
  const arraysl = SLToArray(sl).sort();
  if (arrayjsts.length != arraysl.length) {
    return false;
  }
  for (let i=0;i < arraysl.length; ++i) {
    const vsl = arraysl[i];
    const vjsts = arrayjsts[i];
    if (Math.abs(vsl[0] - vjsts[0]) > TOLERANCE || Math.abs(vsl[1] - vjsts[1]) > TOLERANCE) {
      return false;//[i,arraysl,arrayjsts];
    }
  }
  return true;
}`
)}

function _33(compareResults,interJSTS,interSL){return(
compareResults(interJSTS,interSL) ? "The results are equal!" : "The results are different!"
)}

function _34(cell){return(
cell`compareResults(interJSTS,interSL) ? "The results are equal!" : "The results are different!";`
)}

function _35(md){return(
md`### Implementation`
)}

function _36(tex,md){return(
md`Convert from JSTS Geometry to an array of vertices ${tex`[[x_1,y_1],[x_2,y_2],...,[x_n,y_n]]`}`
)}

function _JSTSGeomToArray(jsts,interJSTS,removeZeroEdges){return(
function(geom) {
  const wktwriter = new jsts.io.WKTWriter();
  const wkt = wktwriter.write(interJSTS);
  const polystr = wkt.slice(wkt.indexOf('(')+2,-2);
  const poly = polystr.split(',').map(pstr => [parseFloat(pstr.split(' ')[0]),parseFloat(pstr.split(' ')[1])]);
  return removeZeroEdges(poly);
}
)}

function _38(cell){return(
cell`JSTSGeomToArray = function(geom) {
  const wktwriter = new jsts.io.WKTWriter();
  const wkt = wktwriter.write(interJSTS);
  const polystr = wkt.slice(wkt.indexOf('(')+2,-2);
  const poly = polystr.split(',').map(pstr => [parseFloat(pstr.split(' ')[0]),parseFloat(pstr.split(' ')[1])]);
  return removeZeroEdges(poly);
}`
)}

function _39(tex,md){return(
md`Convert from Sector List to an array of vertices ${tex`[[x_1,y_1],[x_2,y_2],...,[x_n,y_n]]`}`
)}

function _SLToArray(removeZeroEdges){return(
function(sl) {
  const allpolygons = sl.convertToVertexCirculation().polygons;
  const polys = [];
  for (let id in allpolygons) {
    const p = allpolygons[id];
    if (p.label != 0) {
      const points = [];
      for (let id2 in p.outer_ring) {
        const pnt = p.outer_ring[id2];
        points.push([pnt.x,pnt.y]);
      }
      return removeZeroEdges(points);
    }
  }
  return [];
}
)}

function _41(cell){return(
cell`SLToArray = function(sl) {
  const allpolygons = sl.convertToVertexCirculation().polygons;
  const polys = [];
  for (let id in allpolygons) {
    const p = allpolygons[id];
    if (p.label != 0) {
      const points = [];
      for (let id2 in p.outer_ring) {
        const pnt = p.outer_ring[id2];
        points.push([pnt.x,pnt.y]);
      }
      return removeZeroEdges(points);
    }
  }
  return [];
}`
)}

function _42(md){return(
md`Transform an array for vertices in a string using the Well-Known Text (WKT) standard.`
)}

function _polygonArrayToWKT(){return(
function(polys) {
  const result = [];
  for (let poly of polys) {
    poly = [...poly]; // copy
    poly.push(poly[0]) // the first vertex must be equal to last
    let wkt = poly.map(coord => coord.join(" ")).join(",");
    wkt = "POLYGON(("+wkt+"))";
    result.push(wkt);
  }
  return result;
}
)}

function _44(cell){return(
cell`polygonArrayToWKT = function(polys) {
  const result = [];
  for (let poly of polys) {
    poly = [...poly]; // copy
    poly.push(poly[0]) // the first vertex must be equal to last
    let wkt = poly.map(coord => coord.join(" ")).join(",");
    wkt = "POLYGON(("+wkt+"))";
    result.push(wkt);
  }
  return result;
}`
)}

function _45(tex,md){return(
md`Remove zero-length edges in a vertex circulation ${tex`[[x_1,y_1],[x_2,y_2],...,[x_n,y_n]]`}`
)}

function _removeZeroEdges(){return(
function(arr) {
  const result = [];
  for (let i=0;i<arr.length-1;++i) {
    const p = arr[i];
    const q = arr[i+1];
    if (p[0] != q[0] || p[1] != q[1]) {
      result.push(p);
    }
  } 
  return result;
}
)}

function _47(cell){return(
cell`removeZeroEdges = function(arr) {
  const result = [];
  for (let i=0;i<arr.length-1;++i) {
    const p = arr[i];
    const q = arr[i+1];
    if (p[0] != q[0] || p[1] != q[1]) {
      result.push(p);
    }
  } 
  return result;
}`
)}

function _48(md){return(
md`Creates a HTML canvas drawing an array of vertex circulations.`
)}

function _drawPolygons(DOM){return(
function drawPolygons(polys) {
  const ctx = DOM.context2d(500, 500, 1);
  ctx.strokeStyle = "black";
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.lineWidth = 1;
  for (let poly of polys) {
    ctx.beginPath();
    for (let p of poly) {
      ctx.lineTo(...p);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  return ctx.canvas;
}
)}

function _50(cell){return(
cell`function drawPolygons(polys) {
  const ctx = DOM.context2d(500, 500, 1);
  ctx.strokeStyle = "black";
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.lineWidth = 1;
  for (let poly of polys) {
    ctx.beginPath();
    for (let p of poly) {
      ctx.lineTo(...p);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  return ctx.canvas;
}`
)}

function _jsts(require){return(
require('jsts@2.0.2')
)}

export default function define(runtime, observer) {
  const main = runtime.module();
  main.variable(observer()).define(["md"], _1);
  main.variable(observer()).define(["md"], _2);
  main.variable(observer()).define(["md"], _3);
  main.variable(observer()).define(["tex","md"], _4);
  main.variable(observer("viewof shapeParams")).define("viewof shapeParams", ["Inputs"], _shapeParams);
  main.variable(observer("shapeParams")).define("shapeParams", ["Generators", "viewof shapeParams"], (G, _) => G.input(_));
  main.variable(observer("polygons")).define("polygons", ["coverSquarePolygons","shapeParams"], _polygons);
  main.variable(observer()).define(["cell"], _7);
  main.variable(observer()).define(["drawPolygons","polygons"], _8);
  main.variable(observer()).define(["cell"], _9);
  main.variable(observer()).define(["md"], _10);
  main.variable(observer()).define(["md"], _11);
  main.variable(observer("polygonsJSTS")).define("polygonsJSTS", ["polygonArrayToWKT","polygons","jsts"], _polygonsJSTS);
  main.variable(observer()).define(["cell"], _13);
  main.variable(observer("interJSTS")).define("interJSTS", ["polygonsJSTS"], _interJSTS);
  main.variable(observer()).define(["cell"], _15);
  main.variable(observer()).define(["drawPolygons","JSTSGeomToArray","interJSTS"], _16);
  main.variable(observer()).define(["cell"], _17);
  main.variable(observer()).define(["md"], _18);
  main.variable(observer()).define(["tex","md"], _19);
  main.variable(observer("polygonSL")).define("polygonSL", ["polygons","SectorList"], _polygonSL);
  main.variable(observer()).define(["cell"], _21);
  main.variable(observer()).define(["fieldRender","polygonSL","d3"], _22);
  main.variable(observer()).define(["cell"], _23);
  main.variable(observer()).define(["tex","md"], _24);
  main.variable(observer("interSL")).define("interSL", ["polygonSL"], _interSL);
  main.variable(observer()).define(["cell"], _26);
  main.variable(observer()).define(["drawPolygons","SLToArray","interSL"], _27);
  main.variable(observer()).define(["cell"], _28);
  main.variable(observer()).define(["md"], _29);
  main.variable(observer()).define(["md"], _30);
  main.variable(observer("compareResults")).define("compareResults", ["JSTSGeomToArray","SLToArray"], _compareResults);
  main.variable(observer()).define(["cell"], _32);
  main.variable(observer()).define(["compareResults","interJSTS","interSL"], _33);
  main.variable(observer()).define(["cell"], _34);
  main.variable(observer()).define(["md"], _35);
  main.variable(observer()).define(["tex","md"], _36);
  main.variable(observer("JSTSGeomToArray")).define("JSTSGeomToArray", ["jsts","interJSTS","removeZeroEdges"], _JSTSGeomToArray);
  main.variable(observer()).define(["cell"], _38);
  main.variable(observer()).define(["tex","md"], _39);
  main.variable(observer("SLToArray")).define("SLToArray", ["removeZeroEdges"], _SLToArray);
  main.variable(observer()).define(["cell"], _41);
  main.variable(observer()).define(["md"], _42);
  main.variable(observer("polygonArrayToWKT")).define("polygonArrayToWKT", _polygonArrayToWKT);
  main.variable(observer()).define(["cell"], _44);
  main.variable(observer()).define(["tex","md"], _45);
  main.variable(observer("removeZeroEdges")).define("removeZeroEdges", _removeZeroEdges);
  main.variable(observer()).define(["cell"], _47);
  main.variable(observer()).define(["md"], _48);
  main.variable(observer("drawPolygons")).define("drawPolygons", ["DOM"], _drawPolygons);
  main.variable(observer()).define(["cell"], _50);
  const child1 = runtime.module(define1);
  main.import("SectorList", child1);
  main.import("fieldRender", child1);
  main.import("cell", child1);
  main.import("Legend", child1);
  const child2 = runtime.module(define2);
  main.import("randomPolygon", child2);
  main.import("coverSquarePolygons", child2);
  main.variable(observer("jsts")).define("jsts", ["require"], _jsts);
  return main;
}
